//! XML path parsing and navigation utilities for merge operations.
//!
//! This module provides tools to work with XML element paths during merge operations.
//! Paths use dot notation with optional indices for repeated elements:
//!
//! - `root.parent.child` — Simple path to unique elements
//! - `root.parent.child[2]` — Path to the 2nd `<child>` element (1-based indexing)
//! - `root.parent[3].child[1]` — Mixed path with multiple indices
//!
//! ## Path Format
//!
//! Paths are generated by the diff engine and use 1-based indexing for repeated
//! elements. When no index is specified, `[1]` is implied (first occurrence).
//!
//! ## Use Cases
//!
//! - Parsing diff paths to locate parent nodes for insertion
//! - Navigating XML trees to find specific elements
//! - Normalizing paths when root tags differ (pfSense ↔ OPNsense)

use xml_diff_core::XmlNode;

/// Extract the parent path from a full element path.
///
/// Removes the last segment (child element) from a dot-separated path,
/// returning the parent's path.
///
/// # Arguments
///
/// * `path` - Full path like "root.parent.child" or "root.parent.child[2]"
///
/// # Returns
///
/// Parent path like "root.parent", or None if path has no parent.
///
/// # Examples
///
/// ```ignore
/// split_parent_path("root.parent.child") => Some("root.parent")
/// split_parent_path("root.parent.child[2]") => Some("root.parent")
/// split_parent_path("root") => None
/// ```
pub(super) fn split_parent_path(path: &str) -> Option<String> {
    let (parent, _) = path.rsplit_once('.')?;
    Some(parent.to_string())
}

/// Find a mutable node reference by following a dot-separated path.
///
/// Parses the path into segments and navigates the XML tree to find the
/// target node. Handles repeated elements using 1-based indices.
///
/// ## Path Validation
///
/// - The first segment must match the root tag
/// - The first segment's index must be 1 (e.g., "root[1]" or "root")
/// - All child segments must reference existing nodes
///
/// # Arguments
///
/// * `root` - XML tree root to search within
/// * `path` - Dot-separated path like "root.parent.child[2]"
///
/// # Returns
///
/// Mutable reference to the target node, or None if path is invalid or
/// node doesn't exist.
///
/// # Examples
///
/// ```ignore
/// // Given: <root><items><item>A</item><item>B</item></items></root>
/// find_node_mut_by_path(root, "root.items.item[2]") => Some(&mut B_node)
/// find_node_mut_by_path(root, "root.missing") => None
/// ```
pub(super) fn find_node_mut_by_path<'a>(
    root: &'a mut XmlNode,
    path: &str,
) -> Option<&'a mut XmlNode> {
    let segments = parse_path(path)?;
    if segments.is_empty() {
        return None;
    }
    if segments[0].0 != root.tag || segments[0].1 != 1 {
        return None;
    }
    // Validate root segment and descend through children
    descend(root, &segments[1..])
}

/// Recursively descend through XML tree following path segments.
///
/// Navigates from the current node to its descendants by following each
/// segment in order. Each segment specifies a child tag and index.
///
/// # Arguments
///
/// * `node` - Current node to descend from
/// * `segments` - Remaining path segments to follow
///
/// # Returns
///
/// Mutable reference to the target node, or None if any segment doesn't exist.
fn descend<'a>(node: &'a mut XmlNode, segments: &[(String, usize)]) -> Option<&'a mut XmlNode> {
    if segments.is_empty() {
        // Reached target node
        return Some(node);
    }

    // Find the nth child with matching tag
    let (tag, idx) = &segments[0];
    let child_pos = nth_tag_child_index(&node.children, tag, *idx)?;

    // Recursively descend to next level
    descend(&mut node.children[child_pos], &segments[1..])
}

/// Find the array index of the nth child with a specific tag.
///
/// Searches through children for the nth occurrence of a tag, where n is
/// 1-based (first occurrence = 1, second = 2, etc.).
///
/// # Arguments
///
/// * `children` - List of child nodes to search
/// * `tag` - Tag name to match
/// * `index_1based` - Occurrence number (1-based)
///
/// # Returns
///
/// Array index in children vector, or None if not found.
///
/// # Examples
///
/// ```ignore
/// // Given children: [<a/>, <b/>, <a/>, <c/>]
/// nth_tag_child_index(children, "a", 1) => Some(0)
/// nth_tag_child_index(children, "a", 2) => Some(2)
/// nth_tag_child_index(children, "a", 3) => None
/// ```
fn nth_tag_child_index(children: &[XmlNode], tag: &str, index_1based: usize) -> Option<usize> {
    let mut seen = 0;
    for (idx, child) in children.iter().enumerate() {
        if child.tag == tag {
            seen += 1;
            if seen == index_1based {
                return Some(idx);
            }
        }
    }
    None
}

/// Parse a dot-separated path into segments.
///
/// Splits path on dots and parses each segment into (tag, index) pairs.
/// Indices default to 1 if not specified.
///
/// # Arguments
///
/// * `path` - Path string like "root.parent.child[2]"
///
/// # Returns
///
/// Vector of (tag, index) pairs, or None if any segment is invalid.
///
/// # Examples
///
/// ```ignore
/// parse_path("root.parent.child") => Some([("root", 1), ("parent", 1), ("child", 1)])
/// parse_path("root.items.item[2]") => Some([("root", 1), ("items", 1), ("item", 2)])
/// ```
fn parse_path(path: &str) -> Option<Vec<(String, usize)>> {
    let mut out = Vec::new();
    for segment in path.split('.') {
        out.push(parse_segment(segment)?);
    }
    Some(out)
}

/// Parse a single path segment into (tag, index).
///
/// Handles two formats:
/// - `tag[N]` — Tag with explicit index (e.g., "item[2]")
/// - `tag` — Tag with implicit index 1 (e.g., "child")
///
/// # Arguments
///
/// * `segment` - Path segment like "child" or "item[2]"
///
/// # Returns
///
/// Tuple of (tag_name, 1-based_index), or None if format is invalid.
///
/// # Examples
///
/// ```ignore
/// parse_segment("child") => Some(("child", 1))
/// parse_segment("item[2]") => Some(("item", 2))
/// parse_segment("item[") => None (invalid format)
/// ```
fn parse_segment(segment: &str) -> Option<(String, usize)> {
    let open = segment.find('[');
    let close = segment.rfind(']');
    match (open, close) {
        (Some(start), Some(end)) if end > start => {
            let tag = segment[..start].to_string();
            let idx = segment[start + 1..end].parse::<usize>().ok()?;
            Some((tag, idx))
        }
        (None, None) => Some((segment.to_string(), 1)),
        _ => None,
    }
}

/// Normalize a path to use the output root tag.
///
/// When merging pfSense and OPNsense configs, paths from diff results use
/// the original root tags ("pfsense" or "opnsense"). This function rewrites
/// paths to use the output root tag instead.
///
/// ## Cross-Platform Merging
///
/// During conversion:
/// - Left might be `<pfsense>`, right might be `<opnsense>`
/// - Output needs paths relative to the actual output root
/// - This function normalizes the first segment to match output
///
/// # Arguments
///
/// * `path` - Original path like "pfsense.system.hostname"
/// * `out_root` - Output root tag (e.g., "opnsense")
/// * `left_root` - Left config root tag (e.g., "pfsense")
/// * `right_root` - Right config root tag (e.g., "opnsense")
///
/// # Returns
///
/// Normalized path with output root tag
///
/// # Examples
///
/// ```ignore
/// normalize_root_path("pfsense.system", "opnsense", "pfsense", "opnsense")
///   => "opnsense.system"
/// normalize_root_path("opnsense.filter", "pfsense", "pfsense", "opnsense")
///   => "pfsense.filter"
/// ```
pub(super) fn normalize_root_path(
    path: &str,
    out_root: &str,
    left_root: &str,
    right_root: &str,
) -> String {
    // Split path into first segment and remainder
    let mut segments = path.split('.');
    let Some(first) = segments.next() else {
        return path.to_string();
    };
    let rem = segments.collect::<Vec<_>>().join(".");

    // Replace left/right root tags with output root tag
    let normalized_first = if first.starts_with(left_root) || first.starts_with(right_root) {
        first
            .replacen(left_root, out_root, 1)
            .replacen(right_root, out_root, 1)
    } else {
        first.to_string()
    };

    // Reconstruct path
    if rem.is_empty() {
        normalized_first
    } else {
        format!("{normalized_first}.{rem}")
    }
}
